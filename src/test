import { useState, useEffect, useRef } from 'react';

import { db, auth } from './firebase';

import {
  collection,
  addDoc,
  onSnapshot,
  doc,
  setDoc,
  getDoc,
  getDocs,
  query,
  where,
  serverTimestamp,
  Timestamp,
  updateDoc,
  arrayUnion,
  orderBy,
  limit,
} from 'firebase/firestore';

import {
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  sendEmailVerification,
} from 'firebase/auth';

import { FiSend, FiMic, FiImage, FiUsers } from "react-icons/fi";

import './App.css';

function generateRoomCode(length = 6) {
  const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789'; // avoid confusing chars
  let code = '';
  for (let i = 0; i < length; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

function App() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [username, setUsername] = useState('');
  const [user, setUser] = useState(null);
  const [isVerified, setIsVerified] = useState(false);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [imageFile, setImageFile] = useState(null);
  const [showOriginal, setShowOriginal] = useState({});
  const [modalImage, setModalImage] = useState(null);
  const [usernamesMap, setUsernamesMap] = useState({});
  const [isSignup, setIsSignup] = useState(false);
  const [showProfile, setShowProfile] = useState(false);
  const [sendOutLang, setSendOutLang] = useState('en');
  const [isListening, setIsListening] = useState(false);
  const recognitionRef = useRef(null);
  const [dictationLang, setDictationLang] = useState('en-US');

  // Room related
  const [activeRoom, setActiveRoom] = useState(null); // { id, name, code }
  const [roomNameInput, setRoomNameInput] = useState('');
  const [roomCodeInput, setRoomCodeInput] = useState('');
  const [showRoomCreateForm, setShowRoomCreateForm] = useState(false);
  const [showRoomJoinForm, setShowRoomJoinForm] = useState(false);
  const [showParticipants, setShowParticipants] = useState(false);
  const [roomParticipants, setRoomParticipants] = useState([]); // array of uids

  const messagesEndRef = useRef(null);
  const usersRef = collection(db, 'users');

  useEffect(() => {
    if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
      // don't alert here — user might not use dictation
      return;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    recognition.continuous = false;
    recognition.interimResults = false;

    recognition.lang = dictationLang;

    recognition.onresult = (event) => {
      const transcript = event.results[0][0].transcript;
      setNewMessage((prev) => `${prev} ${transcript}`.trim());
    };

    recognition.onend = () => setIsListening(false);

    recognitionRef.current = recognition;
  }, [dictationLang]);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (usr) => {
      if (usr) {
        await usr.reload(); // refresh user info
        setUser(usr);
        setIsVerified(usr.emailVerified);

        const userDoc = await getDoc(doc(db, 'users', usr.uid));
        if (userDoc.exists()) {
          setUsername(userDoc.data().username);
        }
      } else {
        setUser(null);
        setIsVerified(false);
        setUsername('');
      }
    });
    return unsubscribe;
  }, []);

  // Subscribe to users map (global) when verified
  useEffect(() => {
    if (!isVerified) return;
    const unsub = onSnapshot(usersRef, (snapshot) => {
      const map = {};
      snapshot.docs.forEach((doc) => {
        map[doc.id] = doc.data().username;
      });
      setUsernamesMap(map);
    });
    return unsub;
  }, [isVerified]);

  // Subscribe to messages for active room
  useEffect(() => {
    if (!isVerified || !activeRoom) return;

    const messagesRef = collection(db, 'rooms', activeRoom.id, 'messages');
    const q = query(messagesRef, orderBy('timestamp', 'asc'));

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const msgs = snapshot.docs.map((d) => ({ id: d.id, ...d.data() }));
      setMessages(msgs);
    });

    return () => unsubscribe();
  }, [isVerified, activeRoom]);

  // Keep scroll to bottom when messages change
  useEffect(() => {
    const timeout = setTimeout(() => {
      if (messagesEndRef.current) messagesEndRef.current.scrollIntoView({ behavior: 'auto' });
    }, 50);
    return () => clearTimeout(timeout);
  }, [messages.length]);

  // Subscribe to room participants if in a room
  useEffect(() => {
    if (!isVerified || !activeRoom) return;

    const roomDocRef = doc(db, 'rooms', activeRoom.id);
    const unsubscribe = onSnapshot(roomDocRef, (snap) => {
      if (snap.exists()) {
        setRoomParticipants(snap.data().participants || []);
      }
    });

    return () => unsubscribe();
  }, [isVerified, activeRoom]);

  // Stars (kept as-is)
  useEffect(() => {
    const canvas = document.getElementById('starfield');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    let stars = [];
    let mouseX = 0, mouseY = 0;

    const resize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      stars = Array.from({ length: 100 }, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 2,
        speed: Math.random() * 0.5 + 0.2,
        glow: Math.random() * 20
      }));
    };
    window.addEventListener('resize', resize);
    resize();

    window.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      stars.forEach(star => {
        star.x += (mouseX / canvas.width - 0.5) * star.speed;
        star.y += (mouseY / canvas.height - 0.5) * star.speed;
        if (star.x < 0) star.x = canvas.width;
        if (star.x > canvas.width) star.x = 0;
        if (star.y < 0) star.y = canvas.height;
        if (star.y > canvas.height) star.y = 0;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,0.8)`;
        ctx.shadowBlur = star.glow;
        ctx.shadowColor = 'white';
        ctx.fill();
      });
      requestAnimationFrame(animate);
    };
    animate();

    return () => {
      window.removeEventListener('resize', resize);
    };
  }, []);

  const sendVerificationEmail = async (user) => {
    try {
      await sendEmailVerification(user);
      alert('Verification email sent! Please check your inbox.');
    } catch (error) {
      alert('Failed to send verification email: ' + error.message);
    }
  };

  const handleSignup = async () => {
    if (!username.trim()) {
      alert('Please enter a username.');
      return;
    }

    const q = query(usersRef, where('username', '==', username.trim()));
    const querySnap = await getDocs(q);
    if (!querySnap.empty) {
      alert('Username already taken.');
      return;
    }

    try {
      const cred = await createUserWithEmailAndPassword(auth, email, password);
      await setDoc(doc(db, 'users', cred.user.uid), { username: username.trim() });
      await sendEmailVerification(cred.user);
      alert('Signup successful! Please verify your email.');
    } catch (err) {
      alert('Signup failed: ' + err.message);
    }
  };

  const handleLogin = async () => {
    try {
      const cred = await signInWithEmailAndPassword(auth, email, password);
      setUser(cred.user);
      setIsVerified(cred.user.emailVerified);
      alert('Login successful!');
    } catch (err) {
      alert('Login failed: ' + err.message);
    }
  };

  const handleLogout = () => {
    // leave room when logging out
    setActiveRoom(null);
    signOut(auth);
  };

  // Create room flow
  const createRoom = async () => {
    const name = roomNameInput.trim();
    if (!name) return alert('Please enter a room name.');
    if (name.length > 30) return alert('Room name must be 30 chars or less.');

    // generate unique code
    let newCode = '';
    let attempts = 0;
    while (attempts < 6) {
      newCode = generateRoomCode(6);
      const q = query(collection(db, 'rooms'), where('code', '==', newCode));
      const snap = await getDocs(q);
      if (snap.empty) break; // unique
      attempts++;
    }

    try {
      const roomRef = await addDoc(collection(db, 'rooms'), {
        name,
        code: newCode,
        createdAt: serverTimestamp(),
        participants: [user.uid],
      });

      setActiveRoom({ id: roomRef.id, name, code: newCode });
      setShowRoomCreateForm(false);
      setRoomNameInput('');
    } catch (err) {
      alert('Failed to create room: ' + err.message);
    }
  };

  // Join room flow
  const joinRoom = async () => {
    const code = roomCodeInput.trim().toUpperCase();
    if (!code) return alert('Please enter a room code.');

    try {
      const q = query(collection(db, 'rooms'), where('code', '==', code), limit(1));
      const snap = await getDocs(q);
      if (snap.empty) return alert('No room found with that code.');
      const roomDoc = snap.docs[0];
      const roomData = roomDoc.data();

      // add participant
      const roomRef = doc(db, 'rooms', roomDoc.id);
      await updateDoc(roomRef, { participants: arrayUnion(user.uid) });

      setActiveRoom({ id: roomDoc.id, name: roomData.name, code: roomData.code });
      setShowRoomJoinForm(false);
      setRoomCodeInput('');
    } catch (err) {
      alert('Failed to join room: ' + err.message);
    }
  };

  const leaveRoom = async () => {
    if (!activeRoom) return;
    try {
      const roomRef = doc(db, 'rooms', activeRoom.id);
      const roomSnap = await getDoc(roomRef);
      if (!roomSnap.exists()) {
        setActiveRoom(null);
        return;
      }

      const participants = roomSnap.data().participants || [];
      const updated = participants.filter((id) => id !== user.uid);
      await updateDoc(roomRef, { participants: updated });
      setActiveRoom(null);
      setMessages([]);
    } catch (err) {
      console.error('Leave room error', err);
      setActiveRoom(null);
    }
  };

  const handleSendMessage = async () => {
    if (!newMessage.trim() && !imageFile) return;
    if (!activeRoom) return alert('Join or create a room first.');

    let translatedText = newMessage.trim();
    try {
      if (newMessage.trim()) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);

        const res = await fetch('https://wackie-talkie.onrender.com/translate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: newMessage.trim(),
            source: 'auto',
            target: sendOutLang,
          }),
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (!res.ok) {
          console.error('Translation API error:', res.statusText);
          alert('Translation failed (server issue). Sending original text.');
        } else {
          const data = await res.json();
          translatedText = data.translatedText;
        }
      }
    } catch (err) {
      if (err.name === 'AbortError') {
        alert('Translation timed out. Sending original message.');
      } else {
        alert('Translation failed. Sending original message.');
      }
      console.error('Translation error:', err);
    }

    let imageDataUrl = null;
    if (imageFile) {
      try {
        imageDataUrl = await toBase64(imageFile);
      } catch {
        alert('Image error');
        return;
      }
    }

    try {
      await addDoc(collection(db, 'rooms', activeRoom.id, 'messages'), {
        uid: user.uid,
        text: translatedText,
        originalText: newMessage.trim(),
        image: imageDataUrl,
        timestamp: serverTimestamp(),
      });
    } catch (err) {
      console.error('Send message failed', err);
      alert('Failed to send message: ' + err.message);
    }

    setNewMessage('');
    setImageFile(null);

    setTimeout(() => {
      if (messagesEndRef.current) messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }, 100);
  };

  const toBase64 = (file) =>
    new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => resolve(reader.result);
      reader.onerror = (error) => reject(error);
  });

  if (!user) {  if (!user) {
    return (
      <div className="auth-container">

        <canvas
          id="starfield"
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            zIndex: -1,
          }}
        ></canvas>

        <img
          src={`${process.env.PUBLIC_URL}/images/ChaversaLogo.png`} 
          alt="Chaversa"
          className="auth-image"
        />
        
        <h2>{isSignup ? 'Sign Up' : 'Login'}</h2>
        {isSignup && (
          <input
            type="text"
            placeholder="Username"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
          />
        )}
        <input
          type="email"
          placeholder="Email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <input
          type="password"
          placeholder="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <div className="button-group">
          <button onClick={isSignup ? handleSignup : handleLogin}>
            {isSignup ? 'Sign Up' : 'Login'}
          </button>
          <button onClick={() => setIsSignup((prev) => !prev)}>
            {isSignup ? 'Have an account? Log in' : "Don't have an account? Sign up"}
          </button>
        </div>

        {/* Version + Credits */}
        <div style={{
          position: 'absolute',
          bottom: '10px',
          left: '10px',
          fontSize: '0.75rem',
          color: 'white',
          opacity: 0.8
        }}>
          v1.0.8 — Made by William Cao
        </div>

      </div>
    );
  }

  if (!isVerified) {
    return (
      <div style={{ padding: 20 }}>
        <h2>Please verify your email</h2>
        <p>
          A verification link has been sent to your email address.
          Please check your inbox and click the link to verify your account.
        </p>
        <button onClick={() => sendVerificationEmail(user)}>
          Resend verification email
        </button>

        {/* Add refresh button here */}
        <button
          style={{ marginLeft: '10px' }}
          onClick={async () => {
            if (user) {
              await user.reload(); // Refresh user info from Firebase
              setIsVerified(user.emailVerified);
              if (user.emailVerified) {
                alert('Your email is now verified! You can access the app.');
              } else {
                alert('Email not verified yet. Please check your inbox.');
              }
            }
          }}
        >
          Refresh Verification Status
        </button>

        <br />
        <br />
        <button onClick={handleLogout}>Logout</button>
      </div>
    );
  }

  if (!isVerified) {
    return (
      <div style={{ padding: 20 }}>
        <h2>Please verify your email</h2>
        <p>
          A verification link has been sent to your email address.
          Please check your inbox and click the link to verify your account.
        </p>
        <button onClick={() => sendVerificationEmail(user)}>
          Resend verification email
        </button>

        <button
          style={{ marginLeft: '10px' }}
          onClick={async () => {
            if (user) {
              await user.reload();
              setIsVerified(user.emailVerified);
              if (user.emailVerified) {
                alert('Your email is now verified! You can access the app.');
              } else {
                alert('Email not verified yet. Please check your inbox.');
              }
            }
          }}
        >
          Refresh Verification Status
        </button>

        <br />
        <br />
        <button onClick={handleLogout}>Logout</button>
      </div>
    );
  }

  // If user is verified but hasn't picked a room yet, show create/join UI
  if (!activeRoom) {
    return (
      <div className="thread-container">
        <div className="top-bar">
          <button onClick={handleLogout}>Logout</button>
          <button onClick={() => setShowProfile(true)}>Profile</button>
        </div>

        <h2>Thread Messages</h2>

        <div style={{ display: 'flex', gap: 20, justifyContent: 'center', alignItems: 'center', height: '60vh' }}>
          <div style={{ flex: 1, display: 'flex', justifyContent: 'center' }}>
            <button style={{ width: 220, height: 120, fontSize: '1.1rem' }} onClick={() => { setShowRoomCreateForm(true); setShowRoomJoinForm(false); }}>
              Create Room
            </button>
          </div>

          <div style={{ flex: 1, display: 'flex', justifyContent: 'center' }}>
            <button style={{ width: 220, height: 120, fontSize: '1.1rem' }} onClick={() => { setShowRoomJoinForm(true); setShowRoomCreateForm(false); }}>
              Join Room
            </button>
          </div>
        </div>

        {showRoomCreateForm && (
          <div style={{ display: 'flex', gap: 8, justifyContent: 'center', marginTop: 12 }}>
            <input placeholder="Room name (max 30)" value={roomNameInput} onChange={(e) => setRoomNameInput(e.target.value)} />
            <button onClick={createRoom}>Create</button>
            <button onClick={() => setShowRoomCreateForm(false)}>Cancel</button>
          </div>
        )}

        {showRoomJoinForm && (
          <div style={{ display: 'flex', gap: 8, justifyContent: 'center', marginTop: 12 }}>
            <input placeholder="Enter room code" value={roomCodeInput} onChange={(e) => setRoomCodeInput(e.target.value)} />
            <button onClick={joinRoom}>Join</button>
            <button onClick={() => setShowRoomJoinForm(false)}>Cancel</button>
          </div>
        )}

        {showProfile && (
          <div className="profile-overlay" onClick={() => setShowProfile(false)}>
            <div className="profile-card" onClick={e => e.stopPropagation()}>
              <h3>Profile</h3>
              <p><strong>Email:</strong> {user.email}</p>
              <p><strong>Username:</strong> {username}</p>
              <button onClick={() => setShowProfile(false)}>Close</button>
            </div>
          </div>
        )}

      </div>
    );
  }

  // Main chat UI when activeRoom exists
  return (
    <div className="thread-container">
      <div className="top-bar">
        <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
          <button onClick={leaveRoom}>Leave Room</button>
          <strong style={{ marginLeft: 8 }}>{activeRoom.name}</strong>
          <em style={{ marginLeft: 8 }}>{activeRoom.code}</em>
        </div>

        <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
          <button onClick={handleLogout}>Logout</button>
          <button onClick={() => setShowProfile(true)}>Profile</button>
          <button className="icon-button" onClick={() => setShowParticipants(true)} title="Show participants"><FiUsers size={18} /></button>
        </div>
      </div>

      <h2>Thread Messages</h2>

      <div className="messages-box">
        {messages.map((msg) => (
          <div key={msg.id} className="message-item">
            <strong>{usernamesMap[msg.uid] || 'Unknown'}</strong>{' '}
            <em>{msg.timestamp?.toDate?.()?.toLocaleString() || 'Sending...'}</em>
            <div className="message-content">
              {msg.text && (
                <div>
                  {showOriginal[msg.id] ? msg.originalText || msg.text : msg.text}
                  {msg.originalText && (
                    <button
                      onClick={() =>
                        setShowOriginal((prev) => ({
                          ...prev,
                          [msg.id]: !prev[msg.id],
                        }))
                      }
                      className="toggle-original"
                      title="Toggle original message"
                    >
                      🔁
                    </button>
                  )}
                </div>
              )}

              {msg.image && (
                <img
                  src={msg.image}
                  alt="uploaded"
                  className="message-image"
                  onClick={() => setModalImage(msg.image)}
                />
              )}
            </div>
          </div>
        ))}
        <div ref={messagesEndRef} />
      </div>

      <div className="send-options">
        <label>Send Message In: </label>
        <select value={sendOutLang} onChange={(e) => setSendOutLang(e.target.value)}>
          <option value="en">English</option>
          <option value="es">Spanish</option>
          <option value="fr">French</option>
          <option value="de">German</option>
          <option value="zh-CN">Chinese</option>
          <option value="ja">Japanese</option>
          <option value="ko">Korean</option>
          <option value="ar">Arabic</option>
          <option value="ru">Russian</option>
          <option value="hi">Hindi</option>
        </select>
      </div>

      <div className="chat-input-bar">
        <textarea
          placeholder="Type your message..."
          value={newMessage}
          onChange={(e) => setNewMessage(e.target.value)}
          className="message-input"
          onKeyDown={(e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              handleSendMessage();
            }
          }}
        />

        <label className="icon-button" title="Upload image">
          <FiImage size={20} />
          <input
            type="file"
            accept="image/jpeg,image/png"
            onChange={(e) => setImageFile(e.target.files[0] || null)}
            hidden
            id="image-input"
          />
        </label>

        <button
          className={`icon-button ${isListening ? 'listening' : ''}`}
          onClick={() => {
            if (recognitionRef.current && !isListening) {
              setIsListening(true);
              recognitionRef.current.start();
            } else if (recognitionRef.current && isListening) {
              recognitionRef.current.stop();
            }
          }}
          title="Dictate message"
        >
          <FiMic size={20} />
        </button>

        <button onClick={handleSendMessage} className="send-button" title="Send">
          <FiSend size={40} />
        </button>
      </div>

      {showProfile && (
        <div className="profile-overlay" onClick={() => setShowProfile(false)}>
          <div className="profile-card" onClick={e => e.stopPropagation()}>
            <h3>Profile</h3>
            <p><strong>Email:</strong> {user.email}</p>
            <p><strong>Username:</strong> {username}</p>
            <button onClick={() => setShowProfile(false)}>Close</button>
          </div>
        </div>
      )}

      {showParticipants && (
        <div className="profile-overlay" onClick={() => setShowParticipants(false)}>
          <div className="profile-card" onClick={e => e.stopPropagation()} style={{ width: 360 }}>
            <h3>Participants</h3>
            <div style={{ maxHeight: '40vh', overflowY: 'auto' }}>
              {roomParticipants.length === 0 && <p>No participants</p>}
              {roomParticipants.map((uid) => (
                <div key={uid} style={{ padding: 8, borderBottom: '1px solid #333' }}>
                  {usernamesMap[uid] || uid}
                </div>
              ))}
            </div>
            <div style={{ marginTop: 12, display: 'flex', gap: 8 }}>
              <button onClick={() => setShowParticipants(false)}>Close</button>
              <button onClick={() => { navigator.clipboard?.writeText(activeRoom.code); alert('Code copied'); }}>Copy Code</button>
            </div>
          </div>
        </div>
      )}

      {modalImage && (
        <div className="profile-overlay" onClick={() => setModalImage(null)}>
          <div className="profile-card" onClick={e => e.stopPropagation()}>
            <img src={modalImage} style={{ maxWidth: '100%', maxHeight: '70vh' }} alt="modal" />
            <button onClick={() => setModalImage(null)}>Close</button>
          </div>
        </div>
      )}
    </div>
  );
}

export default App;
